#pragma once
#include"config.h"
#include"lexical_analysis.h"

/********************程序语句的LR分析表********************/
static int action[19][13] = {
 {2,-1,-1,3,4,-1,-1,5,-1,-1,-1,1,-1},
 {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,ACC,-1,-1},
 {-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1},
 {-1,-1,-1,-1,-1,-1,-1,-1,-1,7,-1,-1,-1},
 {2,-1,-1,3,4,-1,-1,5,-1,-1,-1,9,8},
 {-1,-1,104,-1,-1,-1,104,-1,104,-1,104,-1,-1},
 {-1,10,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
 {-1,-1,-1,-1,-1,11,-1,-1,-1,-1,-1,-1,-1},
 {-1,-1,-1,-1,-1,-1,12,-1,-1,-1,-1,-1,-1},
 {-1,-1,-1,-1,-1,-1,105,-1,13,-1,-1,-1,-1},
 {2,-1,-1,3,4,-1,-1,5,-1,-1,-1,14,-1},
 {2,-1,-1,3,4,-1,-1,5,-1,-1,-1,15,-1},
 {-1,-1,103,-1,-1,-1,103,-1,103,-1,103,-1,-1},
 {2,-1,-1,3,4,-1,-1,5,-1,-1,-1,9,16},
 {-1,-1,17,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
 {-1,-1,102,-1,-1,-1,102,-1,102,-1,102,-1,-1},
 {-1,-1,-1,-1,-1,-1,106,-1,-1,-1,-1,-1,-1},
 {2,-1,-1,3,4,-1,-1,5,-1,-1,-1,18,-1},
 {-1,-1,101,-1,-1,-1,101,-1,101,-1,101,-1,-1}
};

/********************算术表达式的LR分析表********************/
static int action1[10][7] =
/*    i  +  *  (  )  #   E  */
{ {3,-1,-1,2,-1,-1,1},
 {-1,4,5,-1,-1,ACC,-1},
 {3,-1,-1,2,-1,-1,6},
 {-1,104,104,-1,104,104,-1},
 {3,-1,-1,2,-1,-1,7},
 {3,-1,-1,2,-1,-1,8},
 {-1,4,5,-1,9,-1,-1},
 {-1,101,5,-1,101,101,-1},
 {-1,102,102,-1,102,102,-1},
 {-1,103,103,-1,103,103,-1}
};

/********************布尔表达式的LR分析表*********************/
static int action2[16][11] =
{ {1,-1,4,-1,5,-1,-1,-1,13,7,8},
 {-1,2,-1,101,-1,101,101,101,-1,-1,-1},
 {3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
 {-1,-1,-1,102,-1,102,102,102,-1,-1,-1},
 {1,-1,4,-1,5,-1,-1,-1,11,7,8},
 {1,-1,4,-1,5,-1,-1,-1,6,7,8},
 {-1,-1,-1,104,-1,9,10,104,-1,-1,-1},
 {1,-1,4,-1,5,-1,-1,-1,14,7,8},
 {1,-1,4,-1,5,-1,-1,-1,15,7,8},
 {105,-1,105,-1,105,-1,-1,-1,-1,-1,-1},
 {107,-1,107,-1,107,-1,-1,-1,-1,-1,-1},
 {-1,-1,-1,12,-1,9,10,-1,-1,-1,-1},
 {-1,-1,-1,103,-1,103,103,103,-1,-1,-1},
 {-1,-1,-1,-1,-1,9,10,ACC,-1,-1,-1},
 {-1,-1,-1,106,-1,9,10,106,-1,-1,-1},
 {-1,-1,-1,108,-1,9,10,108,-1,-1,-1}
};

extern two_exp n;			// 当前字符
extern two_exp stack[1000];	// 语法分析加工处理使用的符号栈
extern int word;			// 查找LR分析表时状态栈的栈顶指针
extern int stack1[100];		// 定义状态栈
extern int sp1;				// 定义状态栈1的栈顶指针
extern two_exp oth;			// 四元式中的空白位置
extern int sign;			// sign=1，表达式为赋值语句  sign=2，表达式为布尔表达式
extern two_exp ibuf[100];	// 缓冲区
extern two_exp sstack[100];	// 符号栈
extern int ssp;				// 指向sstack[100]
extern two_exp n1;			// 当前表达式中的字符

extern int lr1;				// 扫描LR分析表2或3过程中保存的当前状态值

extern two_exp E;			// 非终结符

extern int newt;			// 临时变量

extern fourexp fexp[200];
extern int nxq;				// nxq指向下一个形成的四元式的地址

extern int pointmark;

extern ll labelmark[10];

extern ntab ntab2[200];
extern int label;			// 指向ntab2的指针

extern int lr;				// 扫描LR分析表1过程中保存的当前状态值

extern int labeltemp[10];
extern int pointtemp;

extern int num;				// 缓冲区指针

/********************从二元式读入一个符号*********************/
void readnu();
/************测试字符是否为表达式中的值(不包括":")****************/
int test(int value);
/*********************赋值语句和算术表达式的分析**********************/
int lrparse1(int num);
/*********************************************************/
int change1(int chan);

int change2(int chan);
/***********************布尔表达式的分析**********************/
int lrparse2(int num);
// 返填函数
void backpatch(int p, int t);
/***********************布尔表达式的匹配**********************/
int merg(int p1, int p2);
/*************程序语句处理****************************************/
int lrparse();


/* 语法分析 */
void parsing_global();
